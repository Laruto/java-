[TOC](jvm学习笔记)

# JVM内存区域

## 线程计数器

​	这是一块较小的内存空间，用来指定当前线程执行字节码的行数，每个线程计数器都是**私有的**，因为每个线程都需要记录执行的行数；

　　这里注意下，如果线程执行是一个Java方法的时候，计数器记录的是虚拟机字节码指令的地址；当执行的是Native的方法的时候，计数器指令为空；该内存区域是Java虚拟机唯一没有规定任何OutOfMemoryError的区域。

## Java虚拟栈

​	这个也是一个**线程私有**的，生命周期与线程是同步的，每个方法在执行的同时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出入口等信息，每个方法的调用到执行完成的过程就是一个栈帧入栈到出栈的过程；

​	虚拟机栈规定了２种异常情况，一种是线程请求栈的深度大于虚拟机栈所允许的深度，这时候将会抛出StackOverflowError异常，如果当Java虚拟机允许动态扩展虚拟机栈的时候，当扩展的时候没办法分配到内存的时候就会报OutOfMemoryError异常；

## 本地方法栈

​	与虚拟机栈执行的基本相同，唯一的区别就是虚拟机栈是执行Java方法的，本地方法栈是执行native方法的；

## Java堆

​	堆区是Java虚拟机所管理的内存中**最大**的一块，Java堆是被所有**线程共享**的内存区域，主要存储对象的实例。（所有对象都在堆上分配并不是绝对的）

​	java堆可以再物理上不连续，只要在逻辑上连续即可。

​       当堆中没有内存完成实例分配，并且堆无法扩展的时候，将会抛出OutOfMemoryError异常；当前虚拟机都是可以扩展的；

## 方法区

​	这个也是**线程共享**的内存区域，存储被虚拟机加载的类信息、常量、静态变量、即时编译的代码数据等；      方法区在物理上也是不需要连续的，可以选择固定大小或者扩展的大小，还可以选择不实现垃圾收集，方法区的垃圾回收是比较少的，这就是方法区为什么被称为永久区的原因，但是方法区也是可以执行回收的，该区域主要是针对常量池和类型的卸载；在方法区也规定当方法区无法满足内存分布的时候，将会抛出OutOfMemoryError异常；

### 运行时常量

​	是方法区的一部分，常量池主要用于存放编译生成的各种字面量和符合引用，这部分将在类加载后进入方法区的运行时常量中存放。由于常量池属于方法区的一部分，所以当常量池没有内存空间的时候就抛出OutOfMemoryError异常。

​	运行时常量池具有**动态性**，java语言并不要求常量一定只有编译期才能产生，也就是并非预置于Class文件的内容才能进去方法区运行时常量池，运行期间也可能将新的常量放入池中。

## 直接内存

​	直接内存不是虚拟机运行时的一部分，可以直接访问堆外的内存；所以当内存空间无法动态扩展的时候就会出现OutOfMemoryError异常；

## 对象访问的方式

### 句柄访问

​	句柄访问主要是Java堆中划分一块句柄池，虚拟机栈中存放句柄池中的地址，句柄池中包括对象的实例数据和对象类型的数据的地址，基本分布如下图：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171210174358896-1053299986.png)

### 直接指针访问

​	直接指针访问，就是虚拟机栈直接指向Java堆中的对象类型指针和对象的实例数据，然后对象类型指针在指向方法区中对象类型的实例数据，分布如下图：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171210174840115-965968368.png)

HotSpot就是第二种访问方式，优点在于访问速度快，省去一次指针开销时间。

# 垃圾收集器与内存回收



## 引用计数法

​	对象中添加一个引用计数器，每当有一个地方引用计数器就增加1，引用失效就减少1，计数器为0就不可用；缺点就在于无法处理对象直接相互引用的问题，因为相互引用以后无法使计数器为0，所以无法回收；

## 可达性分析算法

​	也就是我们常说的GC Root,，当一个对象没有与任何引用链相连的时候，就可以对该对象进行回收，下面是Java中GC Root对象使用的几个地方：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171211090111865-202859505.png)

java中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一本说的Native方法）引用的对象

## 引用的分类

强引用：类似`Object ojb = new Object()`这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象

软引用：描述一些还有用单并非必须的对象。在系统将要发生溢出前，将会把这些对象列进垃圾回收范围的二次回收。

弱引用：来描述非必须的对象，比软引用更弱，弱引用的关联对象只能生存到下一次垃圾回收之前，垃圾回收器工作时，无论内存是否足够，都会回收到相关联的对象。

虚引用：一个对象是否有虚引用完全不会对其生存时间产生影响，也无法通过虚引用来取得对象实例，存在的目的是能在这个对象呗收集器回收时收到一个系统通知。

## 无用的类

- 该类的实例都已经被回收，也就是java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有任何地方呗引用，无法再任何地方通过反射访问该类的方法。

虚拟机“可以”对满足3个条件的无用类进行回收（非必须）。

## 内存回收算法

年轻代：当一个对象被创建的时候，内存分配首先分配在年轻代，大部分对象创建以后都不再使用，对象很快变得不可达，就是对象无用，由于垃圾是被年轻代清理掉的，所以被叫做Minor GC或者Young GC。

老年代:对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171211093041709-704224704.png)

1.当一个对象被创建的时候(new)首先会在年轻代的Eden区被创建，直到当GC的时候，根据可达性算法，看一个对象是否消亡，没有消亡的对象会被放入年轻带的Survivor区，消亡的直接被Minor GC Kill掉；

2.进入到Survivor区的对象也不是安全的，当下一次Minor GC来的时候还是会检查Enden和Survivor存放对象区域中对象是否存活，存活放入另外一块Survivor区域；

3.当2个Survivor区切换几次以后，会直接进入老年代，当然进入到老年代也不是安全的，当老年代内存空间不足的时候，会触发Major GC,已经消亡的依然还是被Kill掉；

常见的GC算法有标记--清除，复制，标记--整理这3种算法。分代收集算法是它们的结合。在新生代中使用复制算法，在老年代中使用“标记--清除”或者“标记--整理”算法。

## 垃圾收集器

![](https://upload-images.jianshu.io/upload_images/5916422-8064600b5ef69239.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp)

连线代表可以搭配使用，没有最好的收集器，不同场景不同运用。

下面重点分析CMS和G1这两种收集器。

### Serial和Serial Old

​	是早期jdk中发布的垃圾收集器，特点是都为**单线程**，新生代采用复制算法，老年代采用标记整理算法，两个垃圾收集器在工作的时候必须要停掉所有的用户线程，直到收集完成后才能回复用户线程，由于是单线程工作方式，没有线程交互的开销所以能够活的最高的单线程收集效率，使用在**client模式**下的虚拟机。



### ParNew

​	收集器是Serial收集器的多线程版本，是年轻代的垃圾收集器，可以和Serial old以及CMS老年代收集器搭配使用。Parnew在单CPU环境中的性能没有Serial好，因为单CPU环境下的多线程按照时间顺序串行执行，还要承担线程间交互的额外开销，不过在多cpu环境下，Parnew的性能就会好很多，是运行在**server模式**下的虚拟机首选的新生代收集器。

### Parallel Scanvage 和Parallel Old

​	新生代基于复制算法，老年代基于标记整理算法.Parallel Scanvage也是并行性的多线程收集器，它和Parnew 的区别在于两者的关注点不同。Parnew关注于减少垃圾回收时用户线程停顿的时间，而Parllel Scanvage 关注点事获得最大的吞吐量，也就是CPU运行用户代码与CPU总消耗时间的比值。停顿时间短适合于和用户有交互的程序，吞吐量高则可以高效的利用CPU时间，尽快完成运算任务，主要是和在后台运算不需要太多的交互任务。

​为了实现吞吐量的可控，parallel Scavenge收集器提供了三个重要参数。

1、控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数

MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。不过大家不要异想天开地认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。

2、直接设置吞吐量大小的 -XX:GCTimeRatio参数。

GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。

3、UseAdaptiveSizePolicy开关参数。

​	-XX:+UseAdaptiveSizePolicy是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。



### CMS收集器

​	CMS是老年代垃圾收集器。CMS是一种以获取最短回收停顿时间为目标的收集器，基于标记清除算法来实现。它的工作过程先后分为**初始标记、并发标记、重新标记、并发清除**四个步骤：

![](https://img-blog.csdn.net/20180926082142172?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbnRhb2hhaGFoYWhh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

其中初始标记和重新标记是需要停顿用户线程的，并发标记和并发清理过程是可以和用户线程并发执行的，在整体垃圾收集时间里，初始标记和重新标记所占的时间很少，重新标记阶段又是可以多个垃圾回收线程并行执行的，所以整体用户线程停顿的时间很短。**CMS的缺点**：对CPU资源敏感，CMS默认启动的垃圾回收线程数为(CPU数量+3)/4，在并发阶段由于占用用户线程导致应用变慢，cpu不足4个的时候对用户程序影响很大；CMS无法处理在并发清理阶段新产生的垃圾，只有等下一次垃圾回收标记后才能清除；CMS基于标记清除算法会产生空间碎片，CMS的解决方式是在进行Full GC时开启内存整理,这一过程无法并发，延长了用户线程的停顿时间。

### G1

​	是在jdk1.7时推出的用语新生代和来年代的垃圾收集器，面向server模式。G1把内存区域划分成多个大小相同的独立区域，G1跟踪每个区域里面垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域，这种收集策略可以在有限时间内获取尽可能高的收集效率。G1垃圾回收过程：初始标记（单线程，停顿）、并发标记（单线程，并发）、最终标记（多线程，并行，停顿）、筛选回收（多线程，并行，停顿）。

## 内存分配

- 对象优先在Eden分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 动态对象年龄判定
- 空间分配担保

# 类文件结构

## Class类文件的结构

​	Java实现语言无关的**基石**是JVM和字节码存储格式

​	任何一个Class文件都对应唯一一个类或接口的定义信息。，但是反过来说，类或者接口不一定定义在文件中，有可能通过类加载器直接生成。

​	解析Class文件的数据结构是本章的主要内容。Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何的分隔符，这使得整个Class文件中的存储内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。 
根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结果中只有两种数据类型：**无符号数**和**表**，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。 
​	无符号数：属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。 

​	表：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地一“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由下图的表格中的数据项构成。

![](https://note.youdao.com/yws/api/personal/file/FCC73675187D49FE9AFEA1A1490DDE19?method=download&shareKey=e1c92b86b8e8d89edfbbec00f827636a)

​	无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。

​        Class文件中的数据项无论是顺序还是数量，都是被严格限定的，哪个字节代表什么意思，长度是什么样的，先后顺序如何，都是不允许改变的。

## 魔数与Class文件的版本

​	每个Class文件的头四个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意的改动。文件格式的制定者可以自由地选择魔数值，只要这个魔术值还没有被广泛采用过同时又不会引起混淆即可。 
​	紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1（JDK1.0~1.1使用了45.0~45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，及时文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。 
​	例如：JDK1.1能支持版本号为45.0~45.65535的Class文件，无法执行版本号为46.0以上的Class文件，而JDK1.2则能支持45.0~46.65535的Class文件。现在，最新的JDK版本为1.8，可生成的Class文件主版本号最大值为52.0。 

下图列出了从JDK1.1到JDK1.7，主流JDK版本表一起输出的默认和可支持的Class文件版本号。 

![](https://note.youdao.com/yws/api/personal/file/DB2D619E75654D9E88A8AD07146BC21C?method=download&shareKey=4de8ffc3110bd0abb8c210a7e0351e17)

# 类的加载过程

## 什么是类的加载

​	类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的**方法区**内，然后在**堆区**创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

![](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125941772-1913742708.png)

​	类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误.

加载.class文件的方式
– 从本地系统中直接加载
– 通过网络下载.class文件，例如applet
– 从zip，jar等归档文件中加载.class文件
– 从专有数据库中提取.class文件
– 将Java源文件动态编译为.class文件

## 类的生命周期



![](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125943209-1443333281.png)

​	其中类加载的过程包括了**加载、验证、准备、解析、初始化**五个阶段。在这五个阶段中，**加载、验证、准备**和**初始化**这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

- 加载：查找并加载类的二进制数据

  ​	加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

  1、通过一个类的全限定名来获取其定义的二进制字节流。

  2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

  3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

  ​	相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

  ​	加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在**Java堆**（不一定）中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。（并没有明确规定是在java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面）

  ​	对于数组而言，数组本身不通过类加载器创建，它是由java虚拟机直接创建。但数组类的元素类型最终是要靠类加载器去创建，一个数组类创建过程遵循以下规则：

  如果数组的组件类型是引用类型，那就递归采用类的加载过程去加载这个组件，数据C将在加载该组件类型的类加载的类名称空间上被标识。

  如果数组的组件类型不是引用类型（如int[ ])，java虚拟机会吧数组C标记为引导类加载器关联。

  数组的可见性与他的组件类型的可见性一致

- 连接

  1.验证：确保被加载类的正确性

  ​	验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：

  **文件格式验证**：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。（唯一操作字节流的验证，后面的验证阶段都是基于方法区的存储结构的）

  **元数据验证**：对字节码描述的信息进行**语义分析**（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。这个类的父类是否继承了允许继承的类（被final修饰）。（对类的数据类型进行校检分析）

  **字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。（对类的方法体进行校检分析）

  **符号引用验证**：对类自身以外（常量池中的各种符号引用）的信息进行匹配性校检。目的是确保解析工作能够进行。

  ​	值得一提的是，验证阶段虽然非常重要，但也不是必须的。如果所运行的代码都已经被反复使用，那么可以在实施阶段使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

- 准备：为类的静态变量分配内存，并将其初始化为默认值

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

  ​    1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

  ​    2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

  ​	假设一个类变量的定义为：public static int value = 3；

  ​	那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器\<clinit\>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

  `public static final int vlaue = 3`

  ​	上面的代码中javac编译时会为value生成ConstantValue值，在准备阶段就会根据ConstantValue的设置将vlaue赋值为3

  ​	这里还需要注意如下几点：
  1.对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
  2.对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
  3.对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
  4.如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

- 解析：把类中的符号引用转换为直接引用

  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

  **符号引用**就是一组符号来描述目标，可以是任何字面量。引用的目标并不一定以及加载到内存，只要能无歧义地定位到目标即可

  **直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，引用的目标一定在内存中已存在。

- 初始化:为类的静态变量赋予正确的初始值

  ​	初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。

  ​	初始化阶段是执行类构造器\<client>方法的过程。\<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证\<client>方法执行之前，父类的\<client>方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成\<client>()方法。

  **JVM初始化步骤**

  1、假如这个类还没有被加载和连接，则程序先加载并连接该类

  2、假如该类的直接父类还没有被初始化，则先初始化其直接父类。（虚拟机会保证父类的初始化先与子类的初始化。对于接口而言，只有当父接口中定义的变量使用时，父类才会初始化）

  3、假如类中有初始化语句，则系统依次执行这些初始化语句

  类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：

  – 创建类的实例，也就是new的方式

  – 访问某个类或接口的静态变量，或者对该静态变量赋值

  – 调用类的静态方法

  – 反射（如Class.forName(“com.shengsiyuan.Test”)）

  – 初始化某个类的子类，则其父类也会被初始化

  – Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类

  注意以下几种情况不会执行类初始化：

  - 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
  - 定义对象数组，不会触发该类的初始化。
  - 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
  - 通过类名获取Class对象，不会触发类的初始化。
  - 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
  - 通过ClassLoader默认的loadClass方法，也不会触发初始化动作。

  **结束生命周期**：当一个java应用main函数启动时虚拟机也同时被启动，而只有当在虚拟机实例中的所有非守护进程都结束时，java虚拟机实例才结束生命。

  •在如下几种情况下，Java虚拟机将结束生命周期

  – 执行了System.exit()方法

  – 程序正常执行结束

  – 程序在执行过程中遇到了异常或错误而异常终止

  – 由于操作系统出现错误而导致Java虚拟机进程终止

## 类加载器

​	虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器：

- 启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。(由c++实现，无法被直接引用)
- 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。
- 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。（没有自定义的加载类，默认使用这个）

JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。



![](http://incdn1.b0.upaiyun.com/2017/06/d330251551f6de988239494ce2773095.png)

​	当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试自己去加载。

​	采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。

​	实现双亲委派的代码都在java.lang.ClassLoader的loadClass中：先检查是否被加载过，若没有被加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动加载器作为父加载器。如果父类加载失败，再调用自己的findClass方法进行加载。

# JVM执行引擎

# Java内存模型与线程



# Java并发

## java中的线程安全

按照“安全程度”由强至弱排序，我们将java中各种操作共享的数据分为下面5类：

**不可变**：不可变对象一定是线程安全的。如果共享数据是一个基本数据类型，只需使用`final`关键字修饰就可以保证他是不变的。如果共享对象是一个对象，那就需要保证对象的行为不会对其状态产生影响，最简单的做法是将对象中带有状态的变量都用`final`修饰。

**绝对线程安全**：不管在运行时的环境如何，调用者都不需要任何额外的同步措施。Java API中标注自己是线程安全的类。大多数都不是绝对的线程安全，例如java.util.Vector是线程安全的，但是你必须把使用到Vector的整块代码都用synchronize修饰，才能保证线程安全。

**相对线程安全**：我们通常意义上所讲的线程安全。只需要保证对象单独的操作是线程安全的，但对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段。例如Vector，HashTable,Collections的synchronize()方法包装的集合。

**线程兼容**：是指对象本身并不是线程安全的，但是可以再调用端正确的使用同步手段来保证线程安全。

**线程对立**：无论调用端是否使用同步手段，都无法保证线程安全。一个例子是Thread类的suspend()和resume()方法。（已被摒弃）

## 线程安全的实现方法

**互斥同步（阻塞同步）**：指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个（或是一些，使用信号量的时候）线程使用。**悲观**

比较典型的是synchronize。

**非阻塞同步**：采用基于冲突监测的乐观并发策略，先操作，冲突检测，补偿。这里需要通过硬件来保证操作和冲突检测是原子性的。

CAS（Compare-and-Swap）：需要3个操作数：V（内存位置），A（旧值），B（新值）。当且仅当V符合预期值A时，处理器用新值B替换A。无论是否更新了V值，都会返回A，上述处理过程是一个原子操作。

**无同步方案**：如果一个方法本来就不涉及共享数据，那它自然就无须任何同步，常见的有以下两种：

可重入代码：在代码执行的任何时刻中断，继续时不会出现任何错误。需要注意的是，可重入代码都是线程安全的，但是线程安全的代码不一定都是可重入的。

线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看这些共享数据的代码能不能放在同一个线程中执行。

## 锁优化

**自旋锁与自适应自旋**：挂起和恢复线程都需要转入内核态中完成，这些操作给系统带来很大的压力。而共享数据的锁定状态通常只会持续较短的时间。可以让请求锁的线程“稍等一下”，而不放弃处理器的执行时间，使线程执行一个忙循环，这就是自旋锁。

自适应即是根据上一次等待的结果动态调整本次自旋的次数。（默认是10次）

**锁消除**：是指虚拟机即时编译器运行时，对一些代码要求同步，但被检测到不可能存在共享数据的锁进行清除（判断方法：逃逸分析技术，即堆上的所有数据都不会逃逸出去被其他线程访问到）。

**锁粗化**：虚拟机若侦测到一串零碎的操作都会同一对象加锁，将会把锁同步的范围扩展到整个操作序列的外部。

**偏向锁**：减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。

“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功*，记录锁状态为偏向锁，*以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。

偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。

**轻量级锁**：本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。



| 锁       | 优点                                                         | 缺点                                           | 适用场景                           |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳米级的差距 | 如果线程之间存在锁竞争会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的情况 |
| 轻量级锁 | 竞争的线程不会阻塞，提高线程的响应速度                       | 如果始终得不到锁竞争的线程，使用自旋回消耗cpu  | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗cpu                              | 线程阻塞，响应时间缓慢                         | 追求吞吐量，同步执行时间较长       |

