[TOC](jvm学习笔记)

# JVM内存分配

## 线程计数器

​	这是一块较小的内存空间，用来指定当前线程执行字节码的行数，每个线程计数器都是**私有的**，因为每个线程都需要记录执行的行数；

　　这里注意下，如果线程执行是一个Java方法的时候，计数器记录的是虚拟机字节码指令的地址；当执行的是Native的方法的时候，计数器指令为空；该内存区域是Java虚拟机唯一没有规定任何OutOfMemoryError的区域。

## Java虚拟栈

​	这个也是一个**线程私有**的，生命周期与线程是同步的，每个方法在执行的同时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出入口等信息，每个方法的调用到执行完成的过程就是一个栈帧入栈到出栈的过程；

​	虚拟机栈规定了２种异常情况，一种是线程请求栈的深度大于虚拟机栈所允许的深度，这时候将会抛出StackOverflowError异常，如果当Java虚拟机允许动态扩展虚拟机栈的时候，当扩展的时候没办法分配到内存的时候就会报OutOfMemoryError异常；

## 本地方法栈

​	与虚拟机栈执行的基本相同，唯一的区别就是虚拟机栈是执行Java方法的，本地方法栈是执行native方法的；

## Java堆

​	堆区是Java虚拟机所管理的内存中**最大**的一块，Java堆是被所有**线程共享**的内存区域，主要存储对象的实例。（所有对象都在堆上分配并不是绝对的）

​	java堆可以再物理上不连续，只要在逻辑上连续即可。

​       当堆中没有内存完成实例分配，并且堆无法扩展的时候，将会抛出OutOfMemoryError异常；当前虚拟机都是可以扩展的；

## 方法区

​	这个也是**线程共享**的内存区域，存储被虚拟机加载的类信息、常量、静态变量、即时编译的代码数据等；      方法区在物理上也是不需要连续的，可以选择固定大小或者扩展的大小，还可以选择不实现垃圾收集，方法区的垃圾回收是比较少的，这就是方法区为什么被称为永久区的原因，但是方法区也是可以执行回收的，该区域主要是针对常量池和类型的卸载；在方法区也规定当方法区无法满足内存分布的时候，将会抛出OutOfMemoryError异常；

### 运行时常量

​	是方法区的一部分，常量池主要用于存放编译生成的各种字面量和符合引用，这部分将在类加载后进入方法区的运行时常量中存放。由于常量池属于方法区的一部分，所以当常量池没有内存空间的时候就抛出OutOfMemoryError异常。

​	运行时常量池具有**动态性**，java语言并不要求常量一定只有编译期才能产生，也就是并非预置于Class文件的内容才能进去方法区运行时常量池，运行期间也可能将新的常量放入池中。

## 直接内存

​	直接内存不是虚拟机运行时的一部分，可以直接访问堆外的内存；所以当内存空间无法动态扩展的时候就会出现OutOfMemoryError异常；

## 对象访问的方式

### 句柄访问

​	句柄访问主要是Java堆中划分一块句柄池，虚拟机栈中存放句柄池中的地址，句柄池中包括对象的实例数据和对象类型的数据的地址，基本分布如下图：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171210174358896-1053299986.png)

### 直接指针访问

​	直接指针访问，就是虚拟机栈直接指向Java堆中的对象类型指针和对象的实例数据，然后对象类型指针在指向方法区中对象类型的实例数据，分布如下图：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171210174840115-965968368.png)

HotSpot就是第二种访问方式，优点在于访问速度快，省去一次指针开销时间。

# 垃圾收集器与内存回收



## 引用计数法

​	对象中添加一个引用计数器，每当有一个地方引用计数器就增加1，引用失效就减少1，计数器为0就不可用；缺点就在于无法处理对象直接相互引用的问题，因为相互引用以后无法使计数器为0，所以无法回收；

## 可达性分析算法

​	也就是我们常说的GC Root,，当一个对象没有与任何引用链相连的时候，就可以对该对象进行回收，下面是Java中GC Root对象使用的几个地方：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171211090111865-202859505.png)

java中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一本说的Native方法）引用的对象

## 引用的分类

强引用：类似`Object ojb = new Object()`这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象

软引用：描述一些还有用单并非必须的对象。在系统将要发生溢出前，将会把这些对象列进垃圾回收范围的二次回收。

弱引用：来描述非必须的对象，比软引用更弱，弱引用的关联对象只能生存到下一次垃圾回收之前，垃圾回收器工作时，无论内存是否足够，都会回收到相关联的对象。

虚引用：一个对象是否有虚引用完全不会对其生存时间产生影响，也无法通过虚引用来取得对象实例，存在的目的是能在这个对象呗收集器回收时收到一个系统通知。

## 无用的类

- 该类的实例都已经被回收，也就是java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有任何地方呗引用，无法再任何地方通过反射访问该类的方法。

虚拟机“可以”对满足3个条件的无用类进行回收（非必须）。

## 内存回收算法

年轻代：当一个对象被创建的时候，内存分配首先分配在年轻代，大部分对象创建以后都不再使用，对象很快变得不可达，就是对象无用，由于垃圾是被年轻代清理掉的，所以被叫做Minor GC或者Young GC。

老年代:对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。