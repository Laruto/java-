[TOC](jvm学习笔记)

# JVM内存区域

## 线程计数器

​	这是一块较小的内存空间，用来指定当前线程执行字节码的行数，每个线程计数器都是**私有的**，因为每个线程都需要记录执行的行数；

　　这里注意下，如果线程执行是一个Java方法的时候，计数器记录的是虚拟机字节码指令的地址；当执行的是Native的方法的时候，计数器指令为空；该内存区域是Java虚拟机唯一没有规定任何OutOfMemoryError的区域。

## Java虚拟栈

​	这个也是一个**线程私有**的，生命周期与线程是同步的，每个方法在执行的同时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出入口等信息，每个方法的调用到执行完成的过程就是一个栈帧入栈到出栈的过程；

​	虚拟机栈规定了２种异常情况，一种是线程请求栈的深度大于虚拟机栈所允许的深度，这时候将会抛出StackOverflowError异常，如果当Java虚拟机允许动态扩展虚拟机栈的时候，当扩展的时候没办法分配到内存的时候就会报OutOfMemoryError异常；

## 本地方法栈

​	与虚拟机栈执行的基本相同，唯一的区别就是虚拟机栈是执行Java方法的，本地方法栈是执行native方法的；

## Java堆

​	堆区是Java虚拟机所管理的内存中**最大**的一块，Java堆是被所有**线程共享**的内存区域，主要存储对象的实例。（所有对象都在堆上分配并不是绝对的）

​	java堆可以再物理上不连续，只要在逻辑上连续即可。

​       当堆中没有内存完成实例分配，并且堆无法扩展的时候，将会抛出OutOfMemoryError异常；当前虚拟机都是可以扩展的；

## 方法区

​	这个也是**线程共享**的内存区域，存储被虚拟机加载的类信息、常量、静态变量、即时编译的代码数据等；      方法区在物理上也是不需要连续的，可以选择固定大小或者扩展的大小，还可以选择不实现垃圾收集，方法区的垃圾回收是比较少的，这就是方法区为什么被称为永久区的原因，但是方法区也是可以执行回收的，该区域主要是针对常量池和类型的卸载；在方法区也规定当方法区无法满足内存分布的时候，将会抛出OutOfMemoryError异常；

### 运行时常量

​	是方法区的一部分，常量池主要用于存放编译生成的各种字面量和符合引用，这部分将在类加载后进入方法区的运行时常量中存放。由于常量池属于方法区的一部分，所以当常量池没有内存空间的时候就抛出OutOfMemoryError异常。

​	运行时常量池具有**动态性**，java语言并不要求常量一定只有编译期才能产生，也就是并非预置于Class文件的内容才能进去方法区运行时常量池，运行期间也可能将新的常量放入池中。

## 直接内存

​	直接内存不是虚拟机运行时的一部分，可以直接访问堆外的内存；所以当内存空间无法动态扩展的时候就会出现OutOfMemoryError异常；

## 对象访问的方式

### 句柄访问

​	句柄访问主要是Java堆中划分一块句柄池，虚拟机栈中存放句柄池中的地址，句柄池中包括对象的实例数据和对象类型的数据的地址，基本分布如下图：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171210174358896-1053299986.png)

### 直接指针访问

​	直接指针访问，就是虚拟机栈直接指向Java堆中的对象类型指针和对象的实例数据，然后对象类型指针在指向方法区中对象类型的实例数据，分布如下图：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171210174840115-965968368.png)

HotSpot就是第二种访问方式，优点在于访问速度快，省去一次指针开销时间。

# 垃圾收集器与内存回收



## 引用计数法

​	对象中添加一个引用计数器，每当有一个地方引用计数器就增加1，引用失效就减少1，计数器为0就不可用；缺点就在于无法处理对象直接相互引用的问题，因为相互引用以后无法使计数器为0，所以无法回收；

## 可达性分析算法

​	也就是我们常说的GC Root,，当一个对象没有与任何引用链相连的时候，就可以对该对象进行回收，下面是Java中GC Root对象使用的几个地方：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171211090111865-202859505.png)

java中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一本说的Native方法）引用的对象

## 引用的分类

强引用：类似`Object ojb = new Object()`这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象

软引用：描述一些还有用单并非必须的对象。在系统将要发生溢出前，将会把这些对象列进垃圾回收范围的二次回收。

弱引用：来描述非必须的对象，比软引用更弱，弱引用的关联对象只能生存到下一次垃圾回收之前，垃圾回收器工作时，无论内存是否足够，都会回收到相关联的对象。

虚引用：一个对象是否有虚引用完全不会对其生存时间产生影响，也无法通过虚引用来取得对象实例，存在的目的是能在这个对象呗收集器回收时收到一个系统通知。

## 无用的类

- 该类的实例都已经被回收，也就是java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有任何地方呗引用，无法再任何地方通过反射访问该类的方法。

虚拟机“可以”对满足3个条件的无用类进行回收（非必须）。

## 内存回收算法

年轻代：当一个对象被创建的时候，内存分配首先分配在年轻代，大部分对象创建以后都不再使用，对象很快变得不可达，就是对象无用，由于垃圾是被年轻代清理掉的，所以被叫做Minor GC或者Young GC。

老年代:对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171211093041709-704224704.png)

1.当一个对象被创建的时候(new)首先会在年轻代的Eden区被创建，直到当GC的时候，根据可达性算法，看一个对象是否消亡，没有消亡的对象会被放入年轻带的Survivor区，消亡的直接被Minor GC Kill掉；

2.进入到Survivor区的对象也不是安全的，当下一次Minor GC来的时候还是会检查Enden和Survivor存放对象区域中对象是否存活，存活放入另外一块Survivor区域；

3.当2个Survivor区切换几次以后，会直接进入老年代，当然进入到老年代也不是安全的，当老年代内存空间不足的时候，会触发Major GC,已经消亡的依然还是被Kill掉；

常见的GC算法有标记--清除，复制，标记--整理这3种算法。分代收集算法是它们的结合。在新生代中使用复制算法，在老年代中使用“标记--清除”或者“标记--整理”算法。

## 垃圾收集器

![](https://upload-images.jianshu.io/upload_images/5916422-8064600b5ef69239.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp)

连线代表可以搭配使用，没有最好的收集器，不同场景不同运用。

下面重点分析CMS和G1这两种收集器。

### Serial和Serial Old

​	是早期jdk中发布的垃圾收集器，特点是都为**单线程**，新生代采用复制算法，老年代采用标记整理算法，两个垃圾收集器在工作的时候必须要停掉所有的用户线程，直到收集完成后才能回复用户线程，由于是单线程工作方式，没有线程交互的开销所以能够活的最高的单线程收集效率，使用在**client模式**下的虚拟机。



### ParNew

​	收集器是Serial收集器的多线程版本，是年轻代的垃圾收集器，可以和Serial old以及CMS老年代收集器搭配使用。Parnew在单CPU环境中的性能没有Serial好，因为单CPU环境下的多线程按照时间顺序串行执行，还要承担线程间交互的额外开销，不过在多cpu环境下，Parnew的性能就会好很多，是运行在**server模式**下的虚拟机首选的新生代收集器。

### Parallel Scanvage 和Parallel Old

​	新生代基于复制算法，老年代基于标记整理算法.Parallel Scanvage也是并行性的多线程收集器，它和Parnew 的区别在于两者的关注点不同。Parnew关注于减少垃圾回收时用户线程停顿的时间，而Parllel Scanvage 关注点事获得最大的吞吐量，也就是CPU运行用户代码与CPU总消耗时间的比值。停顿时间短适合于和用户有交互的程序，吞吐量高则可以高效的利用CPU时间，尽快完成运算任务，主要是和在后台运算不需要太多的交互任务。

​为了实现吞吐量的可控，parallel Scavenge收集器提供了三个重要参数。

1、控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数

MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。不过大家不要异想天开地认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。

2、直接设置吞吐量大小的 -XX:GCTimeRatio参数。

GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。

3、UseAdaptiveSizePolicy开关参数。

​	-XX:+UseAdaptiveSizePolicy是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。



### CMS收集器

​	CMS是老年代垃圾收集器。CMS是一种以获取最短回收停顿时间为目标的收集器，基于标记清除算法来实现。它的工作过程先后分为**初始标记、并发标记、重新标记、并发清除**四个步骤：

![](https://img-blog.csdn.net/20180926082142172?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbnRhb2hhaGFoYWhh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

其中初始标记和重新标记是需要停顿用户线程的，并发标记和并发清理过程是可以和用户线程并发执行的，在整体垃圾收集时间里，初始标记和重新标记所占的时间很少，重新标记阶段又是可以多个垃圾回收线程并行执行的，所以整体用户线程停顿的时间很短。**CMS的缺点**：对CPU资源敏感，CMS默认启动的垃圾回收线程数为(CPU数量+3)/4，在并发阶段由于占用用户线程导致应用变慢，cpu不足4个的时候对用户程序影响很大；CMS无法处理在并发清理阶段新产生的垃圾，只有等下一次垃圾回收标记后才能清除；CMS基于标记清除算法会产生空间碎片，CMS的解决方式是在进行Full GC时开启内存整理,这一过程无法并发，延长了用户线程的停顿时间。

### G1

​	是在jdk1.7时推出的用语新生代和来年代的垃圾收集器，面向server模式。G1把内存区域划分成多个大小相同的独立区域，G1跟踪每个区域里面垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域，这种收集策略可以在有限时间内获取尽可能高的收集效率。G1垃圾回收过程：初始标记（单线程，停顿）、并发标记（单线程，并发）、最终标记（多线程，并行，停顿）、筛选回收（多线程，并行，停顿）。

## 内存分配

- 对象优先在Eden分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 动态对象年龄判定
- 空间分配担保

