[TOC](jvm学习笔记)

# JVM内存区域

## 线程计数器

​	这是一块较小的内存空间，用来指定当前线程执行字节码的行数，每个线程计数器都是**私有的**，因为每个线程都需要记录执行的行数；

　　这里注意下，如果线程执行是一个Java方法的时候，计数器记录的是虚拟机字节码指令的地址；当执行的是Native的方法的时候，计数器指令为空；该内存区域是Java虚拟机唯一没有规定任何OutOfMemoryError的区域。

## Java虚拟栈

​	这个也是一个**线程私有**的，生命周期与线程是同步的，每个方法在执行的同时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出入口等信息，每个方法的调用到执行完成的过程就是一个栈帧入栈到出栈的过程；

​	虚拟机栈规定了２种异常情况，一种是线程请求栈的深度大于虚拟机栈所允许的深度，这时候将会抛出StackOverflowError异常，如果当Java虚拟机允许动态扩展虚拟机栈的时候，当扩展的时候没办法分配到内存的时候就会报OutOfMemoryError异常；

## 本地方法栈

​	与虚拟机栈执行的基本相同，唯一的区别就是虚拟机栈是执行Java方法的，本地方法栈是执行native方法的；

## Java堆

​	堆区是Java虚拟机所管理的内存中**最大**的一块，Java堆是被所有**线程共享**的内存区域，主要存储对象的实例。（所有对象都在堆上分配并不是绝对的）

​	java堆可以再物理上不连续，只要在逻辑上连续即可。

​       当堆中没有内存完成实例分配，并且堆无法扩展的时候，将会抛出OutOfMemoryError异常；当前虚拟机都是可以扩展的；

## 方法区

​	这个也是**线程共享**的内存区域，存储被虚拟机加载的类信息、常量、静态变量、即时编译的代码数据等；      方法区在物理上也是不需要连续的，可以选择固定大小或者扩展的大小，还可以选择不实现垃圾收集，方法区的垃圾回收是比较少的，这就是方法区为什么被称为永久区的原因，但是方法区也是可以执行回收的，该区域主要是针对常量池和类型的卸载；在方法区也规定当方法区无法满足内存分布的时候，将会抛出OutOfMemoryError异常；

### 运行时常量

​	是方法区的一部分，常量池主要用于存放编译生成的各种字面量和符合引用，这部分将在类加载后进入方法区的运行时常量中存放。由于常量池属于方法区的一部分，所以当常量池没有内存空间的时候就抛出OutOfMemoryError异常。

​	运行时常量池具有**动态性**，java语言并不要求常量一定只有编译期才能产生，也就是并非预置于Class文件的内容才能进去方法区运行时常量池，运行期间也可能将新的常量放入池中。

## 直接内存

​	直接内存不是虚拟机运行时的一部分，可以直接访问堆外的内存；所以当内存空间无法动态扩展的时候就会出现OutOfMemoryError异常；

## 对象访问的方式

### 句柄访问

​	句柄访问主要是Java堆中划分一块句柄池，虚拟机栈中存放句柄池中的地址，句柄池中包括对象的实例数据和对象类型的数据的地址，基本分布如下图：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171210174358896-1053299986.png)

### 直接指针访问

​	直接指针访问，就是虚拟机栈直接指向Java堆中的对象类型指针和对象的实例数据，然后对象类型指针在指向方法区中对象类型的实例数据，分布如下图：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171210174840115-965968368.png)

HotSpot就是第二种访问方式，优点在于访问速度快，省去一次指针开销时间。

# 垃圾收集器与内存回收



## 引用计数法

​	对象中添加一个引用计数器，每当有一个地方引用计数器就增加1，引用失效就减少1，计数器为0就不可用；缺点就在于无法处理对象直接相互引用的问题，因为相互引用以后无法使计数器为0，所以无法回收；

## 可达性分析算法

​	也就是我们常说的GC Root,，当一个对象没有与任何引用链相连的时候，就可以对该对象进行回收，下面是Java中GC Root对象使用的几个地方：

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171211090111865-202859505.png)

java中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一本说的Native方法）引用的对象

## 引用的分类

强引用：类似`Object ojb = new Object()`这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象

软引用：描述一些还有用单并非必须的对象。在系统将要发生溢出前，将会把这些对象列进垃圾回收范围的二次回收。

弱引用：来描述非必须的对象，比软引用更弱，弱引用的关联对象只能生存到下一次垃圾回收之前，垃圾回收器工作时，无论内存是否足够，都会回收到相关联的对象。

虚引用：一个对象是否有虚引用完全不会对其生存时间产生影响，也无法通过虚引用来取得对象实例，存在的目的是能在这个对象呗收集器回收时收到一个系统通知。

## 无用的类

- 该类的实例都已经被回收，也就是java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有任何地方呗引用，无法再任何地方通过反射访问该类的方法。

虚拟机“可以”对满足3个条件的无用类进行回收（非必须）。

## 内存回收算法

年轻代：当一个对象被创建的时候，内存分配首先分配在年轻代，大部分对象创建以后都不再使用，对象很快变得不可达，就是对象无用，由于垃圾是被年轻代清理掉的，所以被叫做Minor GC或者Young GC。

老年代:对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。

![](https://images2017.cnblogs.com/blog/1005447/201712/1005447-20171211093041709-704224704.png)

1.当一个对象被创建的时候(new)首先会在年轻代的Eden区被创建，直到当GC的时候，根据可达性算法，看一个对象是否消亡，没有消亡的对象会被放入年轻带的Survivor区，消亡的直接被Minor GC Kill掉；

2.进入到Survivor区的对象也不是安全的，当下一次Minor GC来的时候还是会检查Enden和Survivor存放对象区域中对象是否存活，存活放入另外一块Survivor区域；

3.当2个Survivor区切换几次以后，会直接进入老年代，当然进入到老年代也不是安全的，当老年代内存空间不足的时候，会触发Major GC,已经消亡的依然还是被Kill掉；

常见的GC算法有标记--清除，复制，标记--整理这3种算法。分代收集算法是它们的结合。在新生代中使用复制算法，在老年代中使用“标记--清除”或者“标记--整理”算法。

## 垃圾收集器

![](https://upload-images.jianshu.io/upload_images/5916422-8064600b5ef69239.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp)

连线代表可以搭配使用，没有最好的收集器，不同场景不同运用。

下面重点分析CMS和G1这两种收集器。

### Serial和Serial Old

​	是早期jdk中发布的垃圾收集器，特点是都为**单线程**，新生代采用复制算法，老年代采用标记整理算法，两个垃圾收集器在工作的时候必须要停掉所有的用户线程，直到收集完成后才能回复用户线程，由于是单线程工作方式，没有线程交互的开销所以能够活的最高的单线程收集效率，使用在**client模式**下的虚拟机。



### ParNew

​	收集器是Serial收集器的多线程版本，是年轻代的垃圾收集器，可以和Serial old以及CMS老年代收集器搭配使用。Parnew在单CPU环境中的性能没有Serial好，因为单CPU环境下的多线程按照时间顺序串行执行，还要承担线程间交互的额外开销，不过在多cpu环境下，Parnew的性能就会好很多，是运行在**server模式**下的虚拟机首选的新生代收集器。

### Parallel Scanvage 和Parallel Old

​	新生代基于复制算法，老年代基于标记整理算法.Parallel Scanvage也是并行性的多线程收集器，它和Parnew 的区别在于两者的关注点不同。Parnew关注于减少垃圾回收时用户线程停顿的时间，而Parllel Scanvage 关注点事获得最大的吞吐量，也就是CPU运行用户代码与CPU总消耗时间的比值。停顿时间短适合于和用户有交互的程序，吞吐量高则可以高效的利用CPU时间，尽快完成运算任务，主要是和在后台运算不需要太多的交互任务。

​为了实现吞吐量的可控，parallel Scavenge收集器提供了三个重要参数。

1、控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数

MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。不过大家不要异想天开地认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。

2、直接设置吞吐量大小的 -XX:GCTimeRatio参数。

GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。

3、UseAdaptiveSizePolicy开关参数。

​	-XX:+UseAdaptiveSizePolicy是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。



### CMS收集器

​	CMS是老年代垃圾收集器。CMS是一种以获取最短回收停顿时间为目标的收集器，基于标记清除算法来实现。它的工作过程先后分为**初始标记、并发标记、重新标记、并发清除**四个步骤：

![](https://img-blog.csdn.net/20180926082142172?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbnRhb2hhaGFoYWhh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

其中初始标记和重新标记是需要停顿用户线程的，并发标记和并发清理过程是可以和用户线程并发执行的，在整体垃圾收集时间里，初始标记和重新标记所占的时间很少，重新标记阶段又是可以多个垃圾回收线程并行执行的，所以整体用户线程停顿的时间很短。**CMS的缺点**：对CPU资源敏感，CMS默认启动的垃圾回收线程数为(CPU数量+3)/4，在并发阶段由于占用用户线程导致应用变慢，cpu不足4个的时候对用户程序影响很大；CMS无法处理在并发清理阶段新产生的垃圾，只有等下一次垃圾回收标记后才能清除；CMS基于标记清除算法会产生空间碎片，CMS的解决方式是在进行Full GC时开启内存整理,这一过程无法并发，延长了用户线程的停顿时间。

### G1

​	是在jdk1.7时推出的用语新生代和来年代的垃圾收集器，面向server模式。G1把内存区域划分成多个大小相同的独立区域，G1跟踪每个区域里面垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域，这种收集策略可以在有限时间内获取尽可能高的收集效率。G1垃圾回收过程：初始标记（单线程，停顿）、并发标记（单线程，并发）、最终标记（多线程，并行，停顿）、筛选回收（多线程，并行，停顿）。

## 内存分配

- 对象优先在Eden分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 动态对象年龄判定
- 空间分配担保

## 类的加载过程

1.什么是类的加载

​	类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的**方法区**内，然后在**堆区**创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

![](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125941772-1913742708.png)

​	类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误.

加载.class文件的方式
– 从本地系统中直接加载
– 通过网络下载.class文件，例如applet
– 从zip，jar等归档文件中加载.class文件
– 从专有数据库中提取.class文件
– 将Java源文件动态编译为.class文件

2.类的生命周期

![](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125943209-1443333281.png)

​	其中类加载的过程包括了**加载、验证、准备、解析、初始化**五个阶段。在这五个阶段中，**加载、验证、准备**和**初始化**这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

- 加载：查找并加载类的二进制数据

  ​	加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

  1、通过一个类的全限定名来获取其定义的二进制字节流。

  2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

  3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

  ​	相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

  ​	加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在**Java堆**（不一定）中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。（并没有明确规定是在java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面）

  ​	对于数组而言，数组本身不通过类加载器创建，它是由java虚拟机直接创建。但数组类的元素类型最终是要靠类加载器去创建，一个数组类创建过程遵循以下规则：

  如果数组的组件类型是引用类型，那就递归采用类的加载过程去加载这个组件，数据C将在加载该组件类型的类加载的类名称空间上被标识。

  如果数组的组件类型不是引用类型（如int[ ])，java虚拟机会吧数组C标记为引导类加载器关联。

  数组的可见性与他的组件类型的可见性一致

- 连接

  1.验证：确保被加载类的正确性

  ​	验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：

  **文件格式验证**：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。（唯一操作字节流的验证，后面的验证阶段都是基于方法区的存储结构的）

  **元数据验证**：对字节码描述的信息进行**语义分析**（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。这个类的父类是否继承了允许继承的类（被final修饰）。（对类的数据类型进行校检分析）

  **字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。（对类的方法体进行校检分析）

  **符号引用验证**：对类自身以外（常量池中的各种符号引用）的信息进行匹配性校检。目的是确保解析工作能够进行。

  ​	值得一提的是，验证阶段虽然非常重要，但也不是必须的。如果所运行的代码都已经被反复使用，那么可以在实施阶段使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

- 准备：为类的静态变量分配内存，并将其初始化为默认值

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

  ​    1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

  ​    2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

  ​	假设一个类变量的定义为：public static int value = 3；

  ​	那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器\<clinit\>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

  `public static final int vlaue = 3`

  ​	上面的代码中javac编译时会为value生成ConstantValue值，在准备阶段就会根据ConstantValue的设置将vlaue赋值为3

  ​	这里还需要注意如下几点：
  1.对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
  2.对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
  3.对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
  4.如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

- 解析

- 初始化